name: MinGW Build & Release (qemu-simulide)

on:
  workflow_dispatch:
    inputs:
      version:
        description: "Versão/Tag (ex.: v0.1.0)"
        required: true
        type: string
      prerelease:
        description: "Marcar como pré-release?"
        required: false
        default: false
        type: boolean
      notes:
        description: "Notas da release (opcional)"
        required: false
        type: string

permissions:
  contents: write

jobs:
  build-release:
    runs-on: windows-latest

    env:
      ZIP_NAME: qemu-simulide-windows-mingw64-${{ inputs.version }}.zip

    steps:
      - name: Habilitar long paths no Git
        run: |
          git config --system core.longpaths true
          git config --global core.longpaths true

      - name: Checkout (sem submódulos)
        uses: actions/checkout@v4
        with:
          submodules: false
          fetch-depth: 0

      - name: Setup MSYS2 (MINGW64)
        uses: msys2/setup-msys2@v2
        with:
          msystem: MINGW64
          update: true
          install: >-
            git
            base-devel
            mingw-w64-x86_64-toolchain
            mingw-w64-x86_64-python
            mingw-w64-x86_64-pkgconf
            mingw-w64-x86_64-glib2
            mingw-w64-x86_64-pixman
            mingw-w64-x86_64-libgcrypt
            mingw-w64-x86_64-zlib
            mingw-w64-x86_64-ninja
            mingw-w64-x86_64-meson
            mingw-w64-x86_64-ntldd
            mingw-w64-x86_64-bzip2

      - name: Versões das ferramentas
        shell: msys2 {0}
        run: |
          which gcc && gcc --version
          which python3 && python3 --version
          which meson && meson --version
          which ninja && ninja --version
          which ntldd && ntldd --version
          pkg-config --version || true

      # Higienização do ambiente para não herdar flags estranhas
      - name: Limpar variáveis que alteram o configure
        shell: msys2 {0}
        run: |
          set -euxo pipefail
          for v in QEMU_CONFIGURE_OPTS QEMU_CONFIGURE_FLAGS CONFIGURE_OPTS CONFIGURE_FLAGS; do
            unset "$v" || true
          done
          rm -rf build config.log meson-private meson-info || true

      # (1) Detecta campos de qemuArena_t e exporta CFLAGS (-Daction=.. -Dtime=..)
      - name: Detectar campos do qemuArena_t e setar CFLAGS
        id: detect_arena
        shell: msys2 {0}
        continue-on-error: true
        run: |
          set -euo pipefail
          ARENA_HDR="$(grep -RIl --include='*.h' 'typedef struct qemuArena' || true)"
          if [ -z "${ARENA_HDR}" ]; then
            ARENA_HDR="$(grep -RIl --include='*.h' 'qemuArena_t' || true)"
          fi
          if [ -z "${ARENA_HDR}" ]; then
            echo "Falha: não achei header com qemuArena_t."
            exit 2
          fi
          echo "Header do qemuArena_t: ${ARENA_HDR}"
          awk '
            /typedef[[:space:]]+struct[[:space:]]+qemuArena/ {inblk=1; next}
            inblk && /};/ {inblk=0}
            inblk {
              line=$0
              sub(/\/\/.*/,"",line)
              gsub(/\/\*([^*]|\*+[^*\/])*\*\//,"",line)
              if (line ~ /^[[:space:]]*$/) next
              if (line ~ /^[[:space:]]*{/ ) next
              if (line ~ /;/) {
                sub(/.*[[:space:]\*]([A-Za-z_][A-Za-z0-9_]*)[[:space:]]*;.*/,"\\1",line)
                if (line ~ /^[A-Za-z_][A-Za-z0-9_]*$/) print line
              }
            }
          ' "${ARENA_HDR}" | sort -u > /tmp/_arena_fields.txt || true
          if [ ! -s /tmp/_arena_fields.txt ]; then
            printf '%s\n' op cmd event state action ts timestamp time_ns ticks tstamp time > /tmp/_arena_fields.txt
          fi
          mapfile -t FIELDS < /tmp/_arena_fields.txt
          echo "Campos candidatos: ${FIELDS[*]}"

          test_pair () {
            A="$1"; T="$2"
            rm -f /tmp/_probe.c /tmp/_probe.o
            printf '#include <stdint.h>\n' > /tmp/_probe.c
            printf '#include "%s"\n' "${ARENA_HDR}" >> /tmp/_probe.c
            printf 'int main(void){ volatile qemuArena_t *p=(volatile qemuArena_t*)0; (void)p->%s; (void)p->%s; return 0; }\n' "${A}" "${T}" >> /tmp/_probe.c
            gcc -m64 -c /tmp/_probe.c -o /tmp/_probe.o >/dev/null 2>&1
          }

          FOUND_A=""; FOUND_T=""
          for A in "${FIELDS[@]}"; do
            for T in "${FIELDS[@]}"; do
              [ "${A}" = "${T}" ] && continue
              if test_pair "${A}" "${T}"; then
                FOUND_A="${A}"; FOUND_T="${T}"; break 2
              fi
            done
          done

          if [ -n "${FOUND_A}" ] && [ -n "${FOUND_T}" ]; then
            echo "Mapeado: action -> ${FOUND_A} | time -> ${FOUND_T}"
            echo "CFLAGS=-Daction=${FOUND_A} -Dtime=${FOUND_T}" >> "$GITHUB_ENV"
          else
            echo "Não foi po
