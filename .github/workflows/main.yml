      - name: Detectar campos do qemuArena_t e setar CFLAGS (auto a partir do header)
        shell: msys2 {0}
        run: |
          set -euo pipefail

          # 1) Localizar o header com a definição de qemuArena_t
          ARENA_HDR="$(grep -RIl --include='*.h' 'typedef struct qemuArena' || true)"
          if [ -z "${ARENA_HDR}" ]; then
            echo "Não achei o header do qemuArena_t. Candidatos por 'qemuArena_t':"
            grep -RIn --include='*.h' 'qemuArena_t' || true
            exit 1
          fi
          echo "Header do qemuArena_t: ${ARENA_HDR}"

          # 2) Extrair os nomes de membros do struct qemuArena_t do header real
          #    Captura o bloco entre 'typedef struct qemuArena' e o próximo '};'
          #    e lista o último identificador por linha (nome do campo).
          rm -f /tmp/_arena_fields.txt
          awk '
            /typedef[[:space:]]+struct[[:space:]]+qemuArena/ {inblk=1; next}
            inblk && /};/ {inblk=0}
            inblk {
              line=$0
              # remove comentários simples
              sub(/\/\/.*/,"",line)
              sub(/\/\*.*\*\//,"",line)
              # ignora linhas vazias e chaves
              if (line ~ /^[[:space:]]*$/) next
              if (line ~ /^[[:space:]]*{/ ) next
              # pega o último token antes do ';'
              if (line ~ /;/) {
                sub(/.*[[:space:]\*]([A-Za-z_][A-Za-z0-9_]*)[[:space:]]*;.*/,"\\1",line)
                # filtra prováveis não-campos (p.ex. typedefs internos)
                if (line ~ /^[A-Za-z_][A-Za-z0-9_]*$/) print line
              }
            }
          ' "${ARENA_HDR}" | sort -u > /tmp/_arena_fields.txt

          echo "Campos detectados no qemuArena_t:"
          cat /tmp/_arena_fields.txt || true

          # 3) Se não achou nada via parsing, tenta fallback com candidatos comuns
          if [ ! -s /tmp/_arena_fields.txt ]; then
            printf '%s\n' op cmd event state action ts timestamp time_ns ticks tstamp time > /tmp/_arena_fields.txt
            echo "Aviso: não consegui parsear o struct. Usando lista de fallback."
          fi

          mapfile -t FIELDS < /tmp/_arena_fields.txt

          # 4) Função para testar um par (A,T) compilando um probe mínimo
          test_pair () {
            A="$1"; T="$2"
            rm -f /tmp/_probe.c /tmp/_probe.o
            printf '#include <stdint.h>\n' > /tmp/_probe.c
            printf '#include "%s"\n' "${ARENA_HDR}" >> /tmp/_probe.c
            printf 'int main(void){ volatile qemuArena_t *p=(volatile qemuArena_t*)0; (void)p->%s; (void)p->%s; return 0; }\n' "${A}" "${T}" >> /tmp/_probe.c
            gcc -m64 -c /tmp/_probe.c -o /tmp/_probe.o >/dev/null 2>&1
          }

          # 5) Tentar todas as combinações de (action_field, time_field)
          FOUND_A=""
          FOUND_T=""
          for A in "${FIELDS[@]}"; do
            for T in "${FIELDS[@]}"; do
              # Evita testar o mesmo campo para os dois papéis
              if [ "${A}" = "${T}" ]; then continue; fi
              if test_pair "${A}" "${T}"; then
                FOUND_A="${A}"
                FOUND_T="${T}"
                break 2
              fi
            done
          done

          if [ -z "${FOUND_A}" ] || [ -z "${FOUND_T}" ]; then
            echo "Falhou a detecção automática dos campos do qemuArena_t."
            echo "Campos vistos no header: "
            printf ' - %s\n' "${FIELDS[@]}"
            echo "Envie o conteúdo de ${ARENA_HDR} (apenas o typedef da struct) que eu te devolvo o mapeamento exato."
            exit 1
          fi

          echo "Mapeado com sucesso: action -> ${FOUND_A}    time -> ${FOUND_T}"
          echo "CFLAGS=-Daction=${FOUND_A} -Dtime=${FOUND_T}" >> "$GITHUB_ENV"
