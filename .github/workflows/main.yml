name: MinGW Build & Release (qemu-simulide)

on:
  workflow_dispatch:
    inputs:
      version:
        description: "Versão/Tag (ex.: v0.1.0)"
        required: true
        type: string
      prerelease:
        description: "Marcar como pré-release?"
        required: false
        default: false
        type: boolean
      notes:
        description: "Notas da release (opcional)"
        required: false
        type: string

permissions:
  contents: write

jobs:
  build-release:
    runs-on: windows-latest

    env:
      ZIP_NAME: qemu-simulide-windows-mingw64-${{ inputs.version }}.zip

    steps:
      - name: Habilitar long paths no Git
        run: |
          git config --system core.longpaths true
          git config --global core.longpaths true

      - name: Checkout (sem submódulos)
        uses: actions/checkout@v4
        with:
          submodules: false
          fetch-depth: 0
          persist-credentials: true

      - name: Setup MSYS2 (MINGW64)
        uses: msys2/setup-msys2@v2
        with:
          msystem: MINGW64
          update: true
          install: >-
            git
            base-devel
            mingw-w64-x86_64-toolchain
            mingw-w64-x86_64-python
            mingw-w64-x86_64-pkgconf
            mingw-w64-x86_64-glib2
            mingw-w64-x86_64-pixman
            mingw-w64-x86_64-libgcrypt
            mingw-w64-x86_64-zlib
            mingw-w64-x86_64-libslirp
            mingw-w64-x86_64-SDL2
            mingw-w64-x86_64-capstone
            mingw-w64-x86_64-ninja
            mingw-w64-x86_64-meson
            mingw-w64-x86_64-ntldd
            mingw-w64-x86_64-bzip2

      - name: Versões das ferramentas
        shell: msys2 {0}
        run: |
          which gcc && gcc --version
          which python3 && python3 --version
          which meson && meson --version
          which ninja && ninja --version
          which ntldd && ntldd --version
          pkg-config --version || true

      - name: Limpar variáveis que alteram o configure
        shell: msys2 {0}
        run: |
          set -euxo pipefail
          for v in QEMU_CONFIGURE_OPTS QEMU_CONFIGURE_FLAGS CONFIGURE_OPTS CONFIGURE_FLAGS; do
            unset "$v" || true
          done
          rm -rf build config.log meson-private meson-info || true

      # SLIRP: detecta e injeta flags (ou desabilita sem quebrar o build)
      - name: Detectar libslirp (enable/disable + flags)
        shell: msys2 {0}
        run: |
          set -euo pipefail
          SLIRP_PKG=""
          if pkg-config --exists libslirp; then SLIRP_PKG="libslirp"; fi
          if [ -z "$SLIRP_PKG" ] && pkg-config --exists slirp; then SLIRP_PKG="slirp"; fi
          if [ -n "$SLIRP_PKG" ]; then
            echo "SLIRP_FLAG=--enable-slirp" >> "$GITHUB_ENV"
            CF="$(pkg-config --cflags "$SLIRP_PKG" || true)"
            LF="$(pkg-config --libs "$SLIRP_PKG" || true)"
            echo "CPPFLAGS=${CF}" >> "$GITHUB_ENV"
            echo "LDFLAGS=${LF}" >> "$GITHUB_ENV"
            echo "libslirp detectado ($SLIRP_PKG). Flags: ${CF} | ${LF}"
          else
            echo "SLIRP_FLAG=--disable-slirp" >> "$GITHUB_ENV"
            echo "CPPFLAGS=" >> "$GITHUB_ENV"
            echo "LDFLAGS=" >> "$GITHUB_ENV"
            echo "libslirp NÃO detectado; slirp será desabilitado."
          fi

      # ===== Arena: map-or-fail por PROBE (sem heredoc; sem neutralização) =====
      - name: Mapear qemuArena_t (exportar -Daction/-Dtime)
        id: detect_arena
        shell: msys2 {0}
        run: |
          set -euo pipefail

          # Candidatos de header onde pode existir o typedef ou macros relevantes
          CAND_HDRS=()
          for h in \
            system/simuliface.h \
            include/simuliface.h \
            include/qemu/osdep.h \
            qemu/osdep.h \
            ; do
            [ -f "$h" ] && CAND_HDRS+=("$h")
          done
          # também todos os headers que mencionam qemuArena/qemuArena_t
          mapfile -t H_MATCH < <(grep -RIl --include='*.h' -E 'qemuArena_t|struct[[:space:]]+qemuArena' . || true)
          for h in "${H_MATCH[@]}"; do CAND_HDRS+=("$h"); done
          # dedup
          CAND_HDRS=($(printf '%s\n' "${CAND_HDRS[@]}" | awk 'NF' | sort -u))

          # Extrair campos do typedef da struct qemuArena (se encontrarmos)
          TMP_FIELDS="$(mktemp)"
          : > "${TMP_FIELDS}"
          for H in "${CAND_HDRS[@]}"; do
            awk '
              /typedef[[:space:]]+struct[[:space:]]+qemuArena/ {inblk=1}
              inblk && /};/ {inblk=0}
              inblk {
                line=$0
                sub(/\/\/.*/,"",line)
                gsub(/\/\*([^*]|\*+[^*\/])*\*\//,"",line)
                if (line ~ /;/) {
                  sub(/.*[[:space:]\*]([A-Za-z_][A-Za-z0-9_]*)[[:space:]]*;.*/,"\\1",line)
                  if (line ~ /^[A-Za-z_][A-Za-z0-9_]*$/) print line
                }
              }
            ' "$H" || true
          done | sort -u > "${TMP_FIELDS}"

          # fallback: se não achou typedef, ainda assim colete nomes usados nos .c
          if [ ! -s "${TMP_FIELDS}" ]; then
            grep -RIn --include='*.c' -E 'm_arena->([A-Za-z_][A-Za-z0-9_]*)' hw system \
              | sed -E 's/.*m_arena->([A-Za-z_][A-Za-z0-9_]*).*/\1/' \
              | sort -u > "${TMP_FIELDS}" || true
          fi

          if [ ! -s "${TMP_FIELDS}" ]; then
            echo "::error::Não consegui obter lista de campos de arena."
            exit 43
          fi
          mapfile -t FIELDS < "${TMP_FIELDS}"

          # Preferências de nomes
          PREF_ACTION=(action simuAction qemuAction op cmd event state)
          PREF_TIME=(time simuTime qemuTime ts timestamp time_ns ticks tstamp)

          # Função: tenta compilar um probe sem heredoc
          try_probe () {
            A="$1"; T="$2"
            : > /tmp/_probe.c
            echo '#include <stdint.h>' >> /tmp/_probe.c
            for inc in "${CAND_HDRS[@]}"; do
              # só inclui se o arquivo realmente existe no workspace
              if [ -f "$inc" ]; then
                echo "#include \"${inc}\"" >> /tmp/_probe.c
              fi
            done
            # cria alias se só houver 'struct qemuArena'
            echo '#ifndef qemuArena_t' >> /tmp/_probe.c
            echo 'typedef struct qemuArena qemuArena_t;' >> /tmp/_probe.c
            echo '#endif' >> /tmp/_probe.c
            echo 'extern volatile qemuArena_t *m_arena;' >> /tmp/_probe.c
            echo "int main(void){ volatile qemuArena_t *p=(volatile qemuArena_t*)0; (void)p->${A}; (void)p->${T}; return 0; }" >> /tmp/_probe.c
            gcc -m64 -c /tmp/_probe.c -o /tmp/_probe.o >/dev/null 2>&1
          }

          FOUND_A=""; FOUND_T=""

          # 1) preferidos primeiro
          for a in "${PREF_ACTION[@]}"; do
            for t in "${PREF_TIME[@]}"; do
              if printf '%s\n' "${FIELDS[@]}" | grep -qx "$a" && printf '%s\n' "${FIELDS[@]}" | grep -qx "$t"; then
                if try_probe "$a" "$t"; then FOUND_A="$a"; FOUND_T="$t"; break 2; fi
              fi
            done
          done

          # 2) fallback brute-force
          if [ -z "$FOUND_A" ]; then
            for a in "${FIELDS[@]}"; do
              for t in "${FIELDS[@]}"; do
                [ "$a" = "$t" ] && continue
                if try_probe "$a" "$t"; then FOUND_A="$a"; FOUND_T="$t"; break 2; fi
              done
            done
          fi

          if [ -z "$FOUND_A" ] || [ -z "$FOUND_T" ]; then
            echo "::group::Diagnóstico arena"
            echo "Headers testados:"; printf '  - %s\n' "${CAND_HDRS[@]}"
            echo "Campos candidatos:"; printf '  - %s\n' "${FIELDS[@]}"
            echo "::endgroup::"
            echo "::error::Falha ao mapear automaticamente os campos de arena (action/time)."
            exit 43
          fi

          echo "Mapeado: action=${FOUND_A} time=${FOUND_T}"
          echo "CFLAGS=${CFLAGS:+$CFLAGS }-Daction=${FOUND_A} -Dtime=${FOUND_T}" >> "$GITHUB_ENV"

      # ===== Shim UART: inserir DEPOIS dos includes para evitar -Werror =====
      - name: Shim STM32 UART (inserir após #include em system/simuliface.c)
        shell: msys2 {0}
        run: |
          set -euo pipefail
          FILE="system/simuliface.c"
          # se não há referência ao símbolo em lugar nenhum, não polui
          if ! grep -RIn --include='*.c' -E '\bstm32_f103c8_uart_action\b' . >/dev/null 2>&1; then
            echo "Nenhuma referência a stm32_f103c8_uart_action; nada a fazer."
            exit 0
          fi
          if [ ! -f "${FILE}" ]; then
            echo "system/simuliface.c não existe; nada a fazer."
            exit 0
          fi
          # se já existir definição real em algum .c, não insere
          if grep -RIl --include='*.c' -E '^[[:space:]]*void[[:space:]]+stm32_f103c8_uart_action[[:space:]]*\(' . >/dev/null 2>&1; then
            echo "Definição real já presente; nenhum shim."
            exit 0
          fi
          if grep -q 'WEAK_STM32_UART_SHIM' "${FILE}"; then
            echo "Shim já presente; seguindo."
            exit 0
          fi
          LAST_INC="$(grep -n '^[[:space:]]*#include' "$FILE" | tail -n1 | cut -d: -f1 || true)"
          if [ -z "$LAST_INC" ]; then LAST_INC=0; fi
          head -n "${LAST_INC}" "${FILE}" > "${FILE}.new"
          {
            echo ""
            echo "#ifndef WEAK_STM32_UART_SHIM"
            echo "#define WEAK_STM32_UART_SHIM 1"
            echo "void stm32_f103c8_uart_action(void) __attribute__((weak));"
            echo "void stm32_f103c8_uart_action(void){}"
            echo "#endif /* WEAK_STM32_UART_SHIM */"
            echo ""
          } >> "${FILE}.new"
          tail -n +"$((LAST_INC+1))" "${FILE}" >> "${FILE}.new"
          mv "${FILE}.new" "${FILE}"
          echo "Shim fraco inserido após includes em ${FILE}"

      # ===== Configure =====
      - name: Configure (conforme README)
        shell: msys2 {0}
        env:
          PKG_CONFIG_PATH: /mingw64/lib/pkgconfig:/usr/lib/pkgconfig
          CFLAGS: ${{ env.CFLAGS }}
          CPPFLAGS: ${{ env.CPPFLAGS }}
          LDFLAGS: ${{ env.LDFLAGS }}
          SLIRP_FLAG: ${{ env.SLIRP_FLAG }}
        run: |
          set -euxo pipefail
          test -f ./configure
          ./configure --target-list=xtensa-softmmu --extra-cflags=-fPIC \
            ${SLIRP_FLAG} \
            --enable-sdl \
            --enable-capstone \
            --disable-attr --disable-auth-pam --disable-avx2 --disable-avx512bw \
            --disable-blkio --disable-bochs --disable-bpf --disable-brlapi \
            --disable-bzip2 --disable-canokey --disable-cap-ng \
            --disable-cloop --disable-cocoa --disable-colo-proxy --disable-coreaudio \
            --disable-crypto-afalg --disable-curl --disable-curses --disable-dbus-display \
            --disable-dmg --disable-docs --disable-dsound --disable-fuse --disable-fuse-lseek \
            --disable-gettext --disable-gio --disable-glusterfs \
            --disable-gnutls --disable-gtk --disable-gtk-clipboard --disable-guest-agent \
            --disable-guest-agent-msi --disable-hvf --disable-iconv --disable-jack \
            --disable-keyring --disable-kvm --disable-l2tpv3 --disable-libdaxctl \
            --disable-libdw --disable-libiscsi --disable-libkeyutils --disable-libnfs \
            --disable-libpmem --disable-libssh --disable-libudev --disable-libusb \
            --disable-libvduse --disable-linux-aio --disable-linux-io-uring --disable-lzfse \
            --disable-lzo --disable-malloc-trim --disable-membarrier --disable-modules \
            --disable-mpath --disable-multiprocess --disable-netmap --disable-nettle \
            --disable-numa --disable-nvmm --disable-opengl --disable-oss --disable-pa \
            --disable-parallels --disable-pipewire --disable-png --disable-qcow1 \
            --disable-qed --disable-qga-vss --disable-rbd --disable-rdma --disable-replication \
            --disable-sdl-image --disable-seccomp --disable-selinux \
            --disable-smartcard --disable-snappy --disable-sndio --disable-sparse \
            --disable-spice --disable-spice-protocol --disable-stack-protector \
            --disable-tools --disable-tpm --disable-u2f --disable-usb-redir \
            --disable-vde --disable-vdi --disable-vhdx --disable-vhost-crypto \
            --disable-vhost-kernel --disable-vhost-net --disable-vhost-user --disable-vhost-vdpa \
            --disable-virglrenderer --disable-virtfs --disable-vmdk --disable-vmnet \
            --disable-vnc --disable-vnc-jpeg --disable-vnc-sasl --disable-vpc \
            --disable-vte --disable-vvfat --disable-whpx --disable-xen --disable-xkbcommon \
            --disable-zstd \
            --enable-tcg --enable-system \
            --disable-werror

      - name: Build (ninja com captura de stdout/stderr)
        shell: msys2 {0}
        env:
          CFLAGS: ${{ env.CFLAGS }}
          CPPFLAGS: ${{ env.CPPFLAGS }}
          LDFLAGS: ${{ env.LDFLAGS }}
          NINJA_STATUS: "[%f/%t %o/sec] "
        run: |
          set -Eeuo pipefail
          mkdir -p build/_ci_logs
          (
            set +e
            ninja -C build -v \
              1> >(tee build/_ci_logs/_ci_stdout.log) \
              2> >(tee build/_ci_logs/_ci_stderr.log >&2)
            echo $? > build/_ci_logs/_ci_rc.txt
          )
          RC="$(cat build/_ci_logs/_ci_rc.txt || echo 1)"
          if [ "$RC" -ne 0 ]; then
            echo "Build falhou com RC=$RC"
            exit "$RC"
          fi

      - name: Preparar bundle (EXEs + DLLs)
        if: ${{ success() }}
        shell: msys2 {0}
        run: |
          set -euo pipefail
          EXE_PATH="$( (find build -type f -name 'qemu-system-xtensa*.exe' -print -quit 2>/dev/null) || true )"
          if [ -z "${EXE_PATH}" ]; then
            echo "qemu-system-xtensa*.exe não encontrado em build/"
            (find build -maxdepth 3 -type f 2>/dev/null | sed 's/^/  - /' || true)
            exit 1
          fi
          BIN_DIR="$(dirname "${EXE_PATH}")"
          echo "BIN_DIR: ${BIN_DIR}"
          rm -rf bundle
          mkdir -p bundle
          cp -v "${BIN_DIR}"/qemu*.exe bundle/ || true

          if [ -d "pc-bios" ]; then
            mkdir -p bundle/pc-bios
            cp -r pc-bios/* bundle/pc-bios/ || true
          fi

          TMP_DEPS="$(mktemp)"; : > "${TMP_DEPS}"
          shopt -s nullglob
          for exe in bundle/*.exe; do
            ntldd -R "$exe" 2>/dev/null | awk '/=>/ && /\.dll/ {gsub("\\\\","/"); print $3}' >> "${TMP_DEPS}" || true
          done
          if [ -s "${TMP_DEPS}" ]; then
            sort -u "${TMP_DEPS}" | while IFS= read -r dll; do
              [ -f "$dll" ] && cp -n "$dll" bundle/ || true
            done
          fi
          rm -f "${TMP_DEPS}"

          for dll in \
            libwinpthread-1.dll libstdc++-6.dll libgcc_s_seh-1.dll \
            libglib-2.0-0.dll libgobject-2.0-0.dll libgmodule-2.0-0.dll libgthread-2.0-0.dll \
            libintl-8.dll libiconv-2.dll libpcre2-8-0.dll libpixman-1-0.dll \
            libgcrypt-20.dll zlib1.dll \
            SDL2.dll \
            libcapstone.dll \
          ; do
            [ -f "/mingw64/bin/$dll" ] && cp -n "/mingw64/bin/$dll" bundle/ || true
          done

          ls -al bundle || true

      - name: Gerar ZIP
        if: ${{ success() }}
        shell: pwsh
        run: |
          if (Test-Path "${{ env.ZIP_NAME }}") { Remove-Item "${{ env.ZIP_NAME }}" }
          Compress-Archive -Path bundle\* -DestinationPath "${{ env.ZIP_NAME }}"

      - name: Upload artifact (CI)
        if: ${{ success() }}
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.ZIP_NAME }}
          path: ${{ env.ZIP_NAME }}
          if-no-files-found: error

      - name: Criar e enviar tag (idempotente)
        if: ${{ success() }}
        shell: bash
        env:
          TAG_NAME: ${{ inputs.version }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euxo pipefail
          git config --global --add safe.directory "$PWD"
          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git remote set-url origin "https://x-access-token:${GITHUB_TOKEN}@github.com/${GITHUB_REPOSITORY}.git"
          git fetch --tags --force --prune
          if git rev-parse -q --verify "refs/tags/${TAG_NAME}" >/dev/null; then
            echo "Tag ${TAG_NAME} já existe localmente."
          else
            git tag -a "${TAG_NAME}" -m "Release ${TAG_NAME}"
          fi
          if git ls-remote --exit-code --tags origin "refs/tags/${TAG_NAME}" >/dev/null 2>&1; then
            echo "Tag ${TAG_NAME} já existe no remoto; seguindo."
          else
            git push origin "refs/tags/${TAG_NAME}"
          fi

      - name: Criar Release com tag
        if: ${{ success() }}
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ inputs.version }}
          name: qemu-simulide ${{ inputs.version }}
          body: ${{ inputs.notes }}
          prerelease: ${{ inputs.prerelease }}
          target_commitish: ${{ github.sha }}
          files: ${{ env.ZIP_NAME }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Mostrar logs em caso de falha (ninja/meson)
        if: ${{ failure() }}
        shell: msys2 {0}
        run: |
          set -euo pipefail
          echo "===== ÚLTIMAS 300 linhas de _ci_stderr.log ====="
          { test -f build/_ci_logs/_ci_stderr.log && tail -n 300 build/_ci_logs/_ci_stderr.log || echo "sem _ci_stderr.log"; }
          echo
          echo "===== ÚLTIMAS 200 linhas de _ci_stdout.log ====="
          { test -f build/_ci_logs/_ci_stdout.log && tail -n 200 build/_ci_logs/_ci_stdout.log || echo "sem _ci_stdout.log"; }
          echo
          echo "===== grep 'error:' no stderr (últimas 120) ====="
          { test -f build/_ci_logs/_ci_stderr.log && grep -inE "error:|fatal error:" build/_ci_logs/_ci_stderr.log | tail -n 120 || true; }
          echo
          echo "===== grep 'FAILED:' no meson-log (últimas 40) ====="
          { test -f build/meson-logs/meson-log.txt && grep -n "FAILED:" build/meson-logs/meson-log.txt | tail -n 40 || echo "sem meson-log.txt"; }
          echo
          echo "===== TAIL do meson-log.txt (400 linhas) ====="
          { test -f build/meson-logs/meson-log.txt && tail -n 400 build/meson-logs/meson-log.txt || true; }

      - name: Upload logs (sempre)
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: build-logs-${{ github.run_id }}
          path: |
            build/_ci_logs/_ci_stdout.log
            build/_ci_logs/_ci_stderr.log
            build/_ci_logs/_ci_rc.txt
            build/meson-logs/meson-log.txt
            config.log
          if-no-files-found: warn
