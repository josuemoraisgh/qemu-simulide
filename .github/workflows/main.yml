name: MinGW Build & Release (qemu-simulide - GCC/MINGW64)

on:
  workflow_dispatch:
    inputs:
      version:
        description: "Versão/Tag (ex.: v0.1.0)"
        required: true
        type: string
      prerelease:
        description: "Marcar como pré-release?"
        required: false
        default: false
        type: boolean
      notes:
        description: "Notas da release (opcional)"
        required: false
        type: string

permissions:
  contents: write

jobs:
  build-release:
    runs-on: windows-latest

    env:
      ZIP_NAME: qemu-simulide-windows-mingw64-${{ inputs.version }}.zip
      CFLAGS_BASE: -Daction=simuAction -Dtime=simuTime

    steps:
      # ---------------------------------------------
      # Checkout
      # ---------------------------------------------
      - name: Checkout
        uses: actions/checkout@v4
        with:
          submodules: false
          fetch-depth: 0

      # ---------------------------------------------
      # Setup MSYS2 + toolchain MinGW64
      # ---------------------------------------------
      - name: Setup MSYS2 (MINGW64)
        uses: msys2/setup-msys2@v2
        with:
          msystem: MINGW64
          update: true
          install: >-
            base-devel
            git
            mingw-w64-x86_64-toolchain
            mingw-w64-x86_64-python
            mingw-w64-x86_64-meson
            mingw-w64-x86_64-ninja
            mingw-w64-x86_64-pkgconf
            mingw-w64-x86_64-glib2
            mingw-w64-x86_64-pixman
            mingw-w64-x86_64-libgcrypt
            mingw-w64-x86_64-zlib
            mingw-w64-x86_64-SDL2
            mingw-w64-x86_64-capstone
            mingw-w64-x86_64-binutils
            mingw-w64-x86_64-ntldd

      - name: Fix PATH
        shell: bash
        run: echo "PATH=/mingw64/bin:/usr/bin:/bin" >> $GITHUB_ENV

      # ---------------------------------------------
      # Sanity GCC
      # ---------------------------------------------
      - name: Sanity GCC
        shell: msys2 {0}
        run: |
          export PATH="/mingw64/bin:/usr/bin:/bin"
          which gcc
          gcc --version
          echo 'int main(void){return 0;}' > sanity.c
          gcc sanity.c -o sanity.exe
          ./sanity.exe

      # ---------------------------------------------
      # Criar shims em ./ci_shims (FORA de qualquer build/)
      # ---------------------------------------------
      - name: Criar shims (ci_shims)
        shell: msys2 {0}
        run: |
          export PATH="/mingw64/bin:/usr/bin:/bin"

          mkdir -p ci_shims

          cat > ci_shims/ci_shims.h << 'EOF'
          #ifndef CI_SIMULIDE_SHIMS_H
          #define CI_SIMULIDE_SHIMS_H
          void stm32_f103c8_uart_action(void);
          void stm32_f103c8_timer_action(void);
          #endif
          EOF

          cat > ci_shims/ci_shims.c << 'EOF'
          void stm32_f103c8_uart_action(void) {}
          void stm32_f103c8_timer_action(void) {}
          EOF

          gcc -c ci_shims/ci_shims.c -o ci_shims/ci_shims.o
          ar rcs ci_shims/libci_shims.a ci_shims/ci_shims.o

          echo "Conteúdo de ci_shims/:"
          ls -l ci_shims

      # ---------------------------------------------
      # Configure QEMU em diretório separado (_build/)
      # QEMU vai criar _build/build/ sozinho
      # ---------------------------------------------
      - name: Configure QEMU (xtensa-softmmu)
        shell: msys2 {0}
        run: |
          export PATH="/mingw64/bin:/usr/bin:/bin"
          hash -r

          echo "=== GCC EM USO ==="
          which gcc
          gcc --version

          # build root separado para não brigar com nada
          rm -rf _build
          mkdir _build
          cd _build

          SRC_DIR="$(cd .. && pwd)"
          SHIMS_DIR="${SRC_DIR}/ci_shims"
          ARENA="-I${SRC_DIR}/hw/arena"
          SHIMINC="-include ${SHIMS_DIR}/ci_shims.h"

          EXTRA_CFLAGS="${ARENA} ${SHIMINC} ${CFLAGS_BASE}"
          EXTRA_LDFLAGS="${SHIMS_DIR}/libci_shims.a"
          
          # Limpa variáveis que possam interferir
          unset CFLAGS CPPFLAGS LDFLAGS || true
          
          export CC=gcc
          export CXX=g++
          export AR=ar
          export NM=nm
          export RANLIB=ranlib
          export LD=ld
          
          ../configure \
            --target-list=xtensa-softmmu \
            --enable-system \
            --enable-tcg \
            --enable-sdl \
            --enable-capstone \
            --disable-werror

      - name: Build (ninja)
        shell: msys2 {0}
        env:
          NINJA_STATUS: "[%f/%t %o/sec] "
          TERM: dumb
        run: |
          export PATH="/mingw64/bin:/usr/bin:/bin"
          mkdir -p _build/_ci_logs
          (
            set +e
            ninja -C _build/build -v \
              1> >(tee _build/_ci_logs/_ci_stdout.log) \
              2> >(tee _build/_ci_logs/_ci_stderr.log >&2)
            echo $? > _build/_ci_logs/_ci_rc.txt
          )
          RC="$(cat _build/_ci_logs/_ci_rc.txt || echo 1)"
          if [ "$RC" -ne 0 ]; then
            echo "Build falhou com RC=$RC"
            exit "$RC"
          fi


      # ---------------------------------------------
      # Build (ninja) em _build/build
      # ---------------------------------------------
      - name: Build (ninja)
        shell: msys2 {0}
        env:
          NINJA_STATUS: "[%f/%t %o/sec] "
          TERM: dumb
        run: |
          export PATH="/mingw64/bin:/usr/bin:/bin"
          mkdir -p _build/_ci_logs
          (
            set +e
            ninja -C _build/build -v \
              1> >(tee _build/_ci_logs/_ci_stdout.log) \
              2> >(tee _build/_ci_logs/_ci_stderr.log >&2)
            echo $? > _build/_ci_logs/_ci_rc.txt
          )
          RC="$(cat _build/_ci_logs/_ci_rc.txt || echo 1)"
          if [ "$RC" -ne 0 ]; then
            echo "Build falhou com RC=$RC"
            exit "$RC"
          fi

      # ---------------------------------------------
      # (Opcional) Verificar símbolo no libcommon.a
      # ---------------------------------------------
      - name: Verificar símbolo stm32_f103c8_uart_action em libcommon.a
        shell: msys2 {0}
        run: |
          export PATH="/mingw64/bin:/usr/bin:/bin"
          LIBA="$(find _build -type f -name 'libcommon.a' -print -quit || true)"
          if [ -z "$LIBA" ]; then
            echo "::warning::libcommon.a não encontrado; seguindo."
            exit 0
          fi
          if nm -g "$LIBA" | grep -q ' stm32_f103c8_uart_action$'; then
            echo "OK: símbolo presente em $(basename "$LIBA")"
          else
            echo "::error::stm32_f103c8_uart_action NÃO encontrado em $(basename "$LIBA")."
            nm -g "$LIBA" | tail -n 150 || true
            exit 86
          fi

      # ---------------------------------------------
      # Bundle (EXEs + DLLs)
      # ---------------------------------------------
      - name: Preparar bundle (EXEs + DLLs)
        shell: msys2 {0}
        run: |
          export PATH="/mingw64/bin:/usr/bin:/bin"

          EXE_PATH="$(find _build -type f -name 'qemu-system-xtensa*.exe' -print -quit || true)"
          if [ -z "${EXE_PATH}" ]; then
            echo "qemu-system-xtensa*.exe não encontrado em _build/"
            find _build -maxdepth 5 -type f 2>/dev/null | sed 's/^/  - /' || true
            exit 1
          fi

          BIN_DIR="$(dirname "${EXE_PATH}")"
          echo "BIN_DIR: ${BIN_DIR}"

          rm -rf bundle
          mkdir -p bundle
          cp -v "${BIN_DIR}"/qemu*.exe bundle/ || true

          if [ -d "pc-bios" ]; then
            mkdir -p bundle/pc-bios
            cp -r pc-bios/* bundle/pc-bios/ || true
          fi

          TMP_DEPS="$(mktemp)"; : > "${TMP_DEPS}"
          shopt -s nullglob
          for exe in bundle/*.exe; do
            ntldd -R "$exe" 2>/dev/null | awk '/=>/ && /\.dll/ {gsub("\\\\","/"); print $3}' >> "${TMP_DEPS}" || true
          done
          if [ -s "${TMP_DEPS}" ]; then
            sort -u "${TMP_DEPS}" | while IFS= read -r dll; do
              [ -f "$dll" ] && cp -n "$dll" bundle/ || true
            done
          fi
          rm -f "${TMP_DEPS}"

          ls -al bundle || true

      # ---------------------------------------------
      # Gerar ZIP
      # ---------------------------------------------
      - name: Gerar ZIP
        shell: pwsh
        run: |
          if (Test-Path "${{ env.ZIP_NAME }}") { Remove-Item "${{ env.ZIP_NAME }}" }
          Compress-Archive -Path bundle\* -DestinationPath "${{ env.ZIP_NAME }}"

      # ---------------------------------------------
      # Upload artifact
      # ---------------------------------------------
      - name: Upload artifact (CI)
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.ZIP_NAME }}
          path: ${{ env.ZIP_NAME }}
          if-no-files-found: error

      # ---------------------------------------------
      # Criar e enviar tag (idempotente)
      # ---------------------------------------------
      - name: Criar e enviar tag (idempotente)
        if: ${{ success() }}
        shell: bash
        env:
          TAG_NAME: ${{ inputs.version }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euxo pipefail
          git config --global --add safe.directory "$PWD"
          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git remote set-url origin "https://x-access-token:${GITHUB_TOKEN}@github.com/${GITHUB_REPOSITORY}.git"
          git fetch --tags --force --prune
          if git rev-parse -q --verify "refs/tags/${TAG_NAME}" >/dev/null; then
            echo "Tag ${TAG_NAME} já existe localmente."
          else
            git tag -a "${TAG_NAME}" -m "Release ${TAG_NAME}"
          fi
          if git ls-remote --exit-code --tags origin "refs/tags/${TAG_NAME}" >/dev/null 2>&1; then
            echo "Tag ${TAG_NAME} já existe no remoto; seguindo."
          else
            git push origin "refs/tags/${TAG_NAME}"
          fi

      # ---------------------------------------------
      # Criar Release
      # ---------------------------------------------
      - name: Criar Release com tag
        if: ${{ success() }}
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ inputs.version }}
          name: qemu-simulide ${{ inputs.version }}
          body: ${{ inputs.notes }}
          prerelease: ${{ inputs.prerelease }}
          target_commitish: ${{ github.sha }}
          files: ${{ env.ZIP_NAME }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # ---------------------------------------------
      # Logs em caso de falha
      # ---------------------------------------------
      - name: Mostrar logs em caso de falha (ninja/meson)
        if: ${{ failure() }}
        shell: msys2 {0}
        run: |
          set -euo pipefail
          echo "===== ÚLTIMAS 300 linhas de _ci_stderr.log ====="
          { test -f _build/_ci_logs/_ci_stderr.log && tail -n 300 _build/_ci_logs/_ci_stderr.log || echo "sem _ci_stderr.log"; }
          echo
          echo "===== ÚLTIMAS 200 linhas de _ci_stdout.log ====="
          { test -f _build/_ci_logs/_ci_stdout.log && tail -n 200 _build/_ci_logs/_ci_stdout.log || echo "sem _ci_stdout.log"; }
          echo
          echo "===== meson-log.txt (se existir) ====="
          { test -f _build/build/meson-logs/meson-log.txt && cat _build/build/meson-logs/meson-log.txt || echo "sem meson-log.txt"; }

      - name: Upload logs (sempre)
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: build-logs-${{ github.run_id }}
          path: |
            _build/_ci_logs/_ci_stdout.log
            _build/_ci_logs/_ci_stderr.log
            _build/_ci_logs/_ci_rc.txt
            _build/build/meson-logs/meson-log.txt
            _build/config.log
          if-no-files-found: warn
